---

---

<section class="max-w-4xl mx-auto">
    <div
        class="bg-white backdrop-blur-xl border border-slate-200 rounded-3xl shadow-2xl relative overflow-hidden group min-h-[400px] flex flex-col transition-all duration-300"
        id="drop-zone"
    >
        <div
            class="absolute top-0 right-0 w-64 h-64 bg-indigo-500/20 rounded-full blur-3xl -mr-32 -mt-32 pointer-events-none"
        >
        </div>
        <div
            class="absolute bottom-0 left-0 w-64 h-64 bg-emerald-500/20 rounded-full blur-3xl -ml-32 -mb-32 pointer-events-none"
        >
        </div>

        <div
            id="initial-state"
            class="relative z-10 flex flex-col items-center justify-center text-center space-y-6 flex-grow p-8"
        >
            <div
                class="p-6 bg-indigo-50 rounded-full ring-1 ring-indigo-100 mb-4 transition-all duration-500 group-hover:scale-110 group-hover:bg-indigo-100 shadow-xl"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-16 w-16 text-indigo-600"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="1.5"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                    ></path>
                </svg>
            </div>

            <h2 class="text-3xl font-bold text-slate-900 tracking-tight">
                Arrastra tu imagen aqu√≠
            </h2>
            <p class="text-slate-600 max-w-lg text-lg">
                Elimina metadatos GPS, modelo de c√°mara y configuraciones ocultas.
                <span class="block mt-2 text-sm text-indigo-600 font-mono"
                    >Procesamiento 100% local. Nada sube a la nube.</span
                >
            </p>

            <label
                for="file-upload"
                class="mt-4 px-8 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white font-semibold rounded-xl shadow-lg hover:shadow-indigo-500/30 transition-all duration-300 transform hover:-translate-y-1 cursor-pointer flex items-center gap-3"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                </svg>
                Seleccionar Imagen
            </label>
            <input id="file-upload" type="file" accept="image/*" class="hidden" />
        </div>

        <div
            id="processing-state"
            class="hidden absolute inset-0 bg-white/90 backdrop-blur-md z-20 flex flex-col items-center justify-center text-slate-900 p-8"
        >
            <div
                class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-indigo-600 mb-4"
            >
            </div>
            <p class="text-xl font-medium animate-pulse">Limpiando metadatos...</p>
        </div>

        <div
            id="result-state"
            class="hidden relative z-20 flex flex-col md:flex-row gap-6 md:gap-8 p-4 md:p-8 transition-all duration-300 opacity-0 bg-white flex-grow"
        >
            <div
                class="w-full md:w-1/2 flex flex-col items-center justify-center relative min-h-[200px] bg-slate-50 rounded-2xl border border-slate-100 p-2 md:p-0"
            >
                <div
                    class="relative group w-full max-h-[300px] md:max-h-full aspect-auto bg-slate-100 rounded-xl overflow-hidden shadow-sm md:shadow-lg md:border border-slate-200"
                >
                    <img id="result-preview" class="w-full h-full object-contain mx-auto" />
                    <div
                        class="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent opacity-0 group-hover:opacity-100 transition-opacity flex items-end justify-center pb-4 pointer-events-none"
                    >
                        <span class="text-white text-sm font-medium">Vista Previa</span>
                    </div>
                </div>
            </div>

            <div class="w-full md:w-1/2 flex flex-col">
                <div class="flex items-center gap-2 mb-3 md:mb-4">
                    <div class="h-6 w-1 md:h-8 bg-indigo-600 rounded-full"></div>
                    <h3 class="text-xl md:text-2xl font-bold text-slate-800">
                        An√°lisis Completado
                    </h3>
                </div>

                <div
                    id="metadata-list"
                    class="flex-grow bg-slate-50 rounded-xl border border-slate-200 p-3 md:p-4 mb-4 md:mb-6 font-mono text-xs md:text-sm overflow-y-auto max-h-[200px] md:max-h-[300px]"
                >
                </div>

                <button
                    id="download-btn"
                    class="w-full py-3 md:py-4 bg-emerald-600 hover:bg-emerald-500 text-white font-bold rounded-xl shadow-lg hover:shadow-emerald-500/30 transition-all flex items-center justify-center gap-2 transform active:scale-95 text-sm md:text-base"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        class="h-5 w-5 md:h-6 md:w-6"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                    >
                        <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                        ></path>
                    </svg>
                    <span>Descargar Imagen Limpia</span>
                </button>

                <button
                    id="reset-btn"
                    class="mt-3 md:mt-4 text-xs md:text-sm text-slate-500 hover:text-indigo-600 flex items-center justify-center gap-1 transition-colors py-2"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        class="w-4 h-4"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        ><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path
                            d="M3 3v5h5"></path><path
                            d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path><path
                            d="M16 21h5v-5"></path></svg
                    >
                    Limpiar otra imagen
                </button>
            </div>
        </div>
    </div>
</section>

<script>
    const dropZone = document.getElementById("drop-zone");
    const initialState = document.getElementById("initial-state");
    const fileInput = document.getElementById("file-upload") as HTMLInputElement;
    const processingState = document.getElementById("processing-state");
    const resultState = document.getElementById("result-state");
    const resultPreview = document.getElementById("result-preview") as HTMLImageElement;
    const downloadBtn = document.getElementById("download-btn");
    const resetBtn = document.getElementById("reset-btn");
    const metadataList = document.getElementById("metadata-list");

    ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        dropZone?.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e: Event) {
        e.preventDefault();
        e.stopPropagation();
    }

    ["dragenter", "dragover"].forEach((eventName) => {
        dropZone?.addEventListener(eventName, highlight, false);
    });

    ["dragleave", "drop"].forEach((eventName) => {
        dropZone?.addEventListener(eventName, unhighlight, false);
    });

    function highlight() {
        if (initialState && !initialState.classList.contains("hidden")) {
            dropZone?.classList.add("ring-2", "ring-indigo-500", "scale-[1.02]");
        }
    }

    function unhighlight() {
        dropZone?.classList.remove("ring-2", "ring-indigo-500", "scale-[1.02]");
    }

    dropZone?.addEventListener("drop", handleDrop, false);
    fileInput?.addEventListener("change", handleFiles, false);

    function handleDrop(e: DragEvent) {
        const dt = e.dataTransfer;
        const files = dt?.files;
        if (files) handleFiles(files);
    }

    function handleFiles(e: any) {
        const files = e instanceof FileList ? e : e.target.files;
        if (files && files.length > 0) {
            processImage(files[0]);
        }
    }

    async function processImage(file: File) {
        processingState?.classList.remove("hidden");
        initialState?.classList.add("hidden");

        const metadata = await extractExif(file);

        const reader = new FileReader();
        reader.onload = function (e) {
            const img = new Image();
            img.onload = function () {
                if (resultPreview) resultPreview.src = img.src;

                renderMetadataLog(metadata, file);

                const canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext("2d");
                ctx?.drawImage(img, 0, 0);

                canvas.toBlob((blob) => {
                    if (!blob) return;
                    const cleanUrl = URL.createObjectURL(blob);

                    downloadBtn!.onclick = () => {
                        const a = document.createElement("a");
                        a.href = cleanUrl;
                        a.download = `CLEAN_${file.name.split(".")[0]}.webp`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    };

                    processingState?.classList.add("hidden");
                    resultState?.classList.remove("hidden");
                    setTimeout(() => resultState?.classList.remove("opacity-0"), 50);
                }, "image/webp");
            };
            img.src = e.target?.result as string;
        };
        reader.readAsDataURL(file);
    }

    function renderMetadataLog(tags: Record<string, any>, file: File) {
        if (!metadataList) return;

        const hasData = Object.keys(tags).length > 0;
        let html = "";

        if (hasData) {
            html += `<div class="font-bold text-amber-600 mb-2">‚ö†Ô∏è RIESGOS DE PRIVACIDAD ENCONTRADOS:</div>`;
            html += `<ul class="space-y-1">`;

            if (tags["GPSLocation"]) {
                html += `<li class="text-red-600 font-bold flex justify-between"><span>üìç GPS:</span> <span class="text-[10px] sm:text-xs text-right max-w-[150px] break-words">${tags["GPSLocation"]}</span></li>`;
            } else if (tags["GPSDetected"]) {
                html += `<li class="text-red-600 font-bold flex justify-between"><span>üìç UBICACI√ìN GPS:</span> <span>DETECTADA</span></li>`;
            } else {
                html += `<li class="text-emerald-600 flex justify-between opacity-70"><span>üìç UBICACI√ìN GPS:</span> <span>NO ENCONTRADA</span></li>`;
            }

            if (tags["Model"]) {
                html += `<li class="text-amber-700 flex justify-between"><span>üì∑ C√ÅMARA:</span> <span>${tags["Model"]}</span></li>`;
            }

            if (tags["Software"]) {
                html += `<li class="text-slate-600 flex justify-between"><span>üíæ SOFTWARE:</span> <span>${tags["Software"]}</span></li>`;
            }

            if (tags["DateTimeOriginal"]) {
                html += `<li class="text-blue-600 flex justify-between"><span>üìÖ FECHA:</span> <span>${tags["DateTimeOriginal"]}</span></li>`;
            }

            html += `</ul>`;

            html += `<div class="mt-4 border-t border-slate-200 pt-2">`;
            html += `<div class="text-[10px] text-slate-400 uppercase font-bold mb-1">OTROS DETALLES T√âCNICOS</div>`;
            for (const [key, val] of Object.entries(tags)) {
                if (
                    [
                        "GPSLatitude",
                        "GPSLongitude",
                        "Model",
                        "Software",
                        "DateTimeOriginal",
                        "GPSDetected",
                        "GPSLocation",
                    ].includes(key)
                )
                    continue;
                html += `<div class="flex justify-between text-slate-500"><span>${key}:</span> <span class="truncate max-w-[120px]">${val}</span></div>`;
            }
            html += `</div>`;
        } else {
            html = `<div class="h-full flex flex-col items-center justify-center text-slate-400">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mb-2 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <p>No se encontraron metadatos EXIF legibles.</p>
                <p class="text-xs opacity-70 mt-1">Es posible que la imagen ya est√© limpia.</p>
            </div>`;
        }

        metadataList.innerHTML = html;
    }

    async function extractExif(file: File): Promise<Record<string, any>> {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const view = new DataView(e.target!.result as ArrayBuffer);
                    if (view.getUint16(0, false) != 0xffd8) return resolve({});

                    let offset = 2;
                    const length = view.byteLength;
                    const tags: Record<string, any> = {};

                    const getBytesPerComponent = (type: number) => {
                        if (type === 1 || type === 2 || type === 7) return 1;
                        if (type === 3) return 2;
                        if (type === 4 || type === 9) return 4;
                        if (type === 5 || type === 10) return 8;
                        return 0;
                    };

                    while (offset < length) {
                        if (view.getUint8(offset) != 0xff) break;

                        const marker = view.getUint8(offset + 1);

                        if (marker == 0xe1) {
                            const exifLength = view.getUint16(offset + 2, false);
                            if (view.getUint32(offset + 4, false) !== 0x45786966) {
                                offset += 2 + exifLength;
                                continue;
                            }

                            const tiffStart = offset + 10;
                            const littleEndian = view.getUint16(tiffStart, false) === 0x4949;
                            const ifdOffset = view.getUint32(tiffStart + 4, littleEndian);

                            if (ifdOffset < 8) {
                                offset += 2 + exifLength;
                                continue;
                            }

                            const parseIFD = (offset: number) => {
                                const numEntries = view.getUint16(offset, littleEndian);
                                for (let i = 0; i < numEntries; i++) {
                                    const entryOffset = offset + 2 + i * 12;
                                    const tag = view.getUint16(entryOffset, littleEndian);
                                    const type = view.getUint16(entryOffset + 2, littleEndian);
                                    const numValues = view.getUint32(entryOffset + 4, littleEndian);
                                    const bytePerComp = getBytesPerComponent(type);
                                    const dataSize = numValues * bytePerComp;

                                    let valueOffset;
                                    if (dataSize > 4) {
                                        valueOffset =
                                            tiffStart +
                                            view.getUint32(entryOffset + 8, littleEndian);
                                    } else {
                                        valueOffset = entryOffset + 8;
                                    }

                                    if (tag === 0x8825) {
                                        const gpsOffset = view.getUint32(
                                            entryOffset + 8,
                                            littleEndian
                                        );
                                        tags["GPSDetected"] = true;
                                        const gpsTags = parseGPS(
                                            tiffStart + gpsOffset,
                                            littleEndian
                                        );
                                        if (gpsTags) tags["GPSLocation"] = gpsTags;
                                    } else if (tag === 0x0110) {
                                        tags["Model"] = readString(valueOffset, numValues);
                                    } else if (tag === 0x0131) {
                                        tags["Software"] = readString(valueOffset, numValues);
                                    } else if (tag === 0x9003) {
                                        tags["DateTimeOriginal"] = readString(
                                            valueOffset,
                                            numValues
                                        );
                                    }
                                }
                            };

                            const parseGPS = (offset: number, littleEndian: boolean) => {
                                const numEntries = view.getUint16(offset, littleEndian);
                                let lat = null,
                                    latRef = null,
                                    lon = null,
                                    lonRef = null;

                                for (let i = 0; i < numEntries; i++) {
                                    const entryOffset = offset + 2 + i * 12;
                                    const tag = view.getUint16(entryOffset, littleEndian);
                                    const type = view.getUint16(entryOffset + 2, littleEndian);
                                    const numValues = view.getUint32(entryOffset + 4, littleEndian);
                                    const dataSize = numValues * getBytesPerComponent(type);

                                    let valueOffset;
                                    if (dataSize > 4) {
                                        valueOffset =
                                            tiffStart +
                                            view.getUint32(entryOffset + 8, littleEndian);
                                    } else {
                                        valueOffset = entryOffset + 8;
                                    }

                                    if (tag === 0x0001) {
                                        latRef = String.fromCharCode(view.getUint8(valueOffset));
                                    } else if (tag === 0x0002) {
                                        lat = readRational(valueOffset, 3, littleEndian);
                                    } else if (tag === 0x0003) {
                                        lonRef = String.fromCharCode(view.getUint8(valueOffset));
                                    } else if (tag === 0x0004) {
                                        lon = readRational(valueOffset, 3, littleEndian);
                                    }
                                }

                                if (lat && lon) {
                                    const lr = latRef && latRef !== "\0" ? latRef : "N";
                                    const lor = lonRef && lonRef !== "\0" ? lonRef : "E";
                                    return `${lat[0]}¬∞ ${lat[1]}' ${lat[2]}" ${lr}, ${lon[0]}¬∞ ${lon[1]}' ${lon[2]}" ${lor}`;
                                }
                                return null;
                            };

                            const readString = (offset: number, length: number) => {
                                let str = "";
                                for (let n = 0; n < length && n < 100; n++) {
                                    const charCode = view.getUint8(offset + n);
                                    if (charCode === 0) break;
                                    str += String.fromCharCode(charCode);
                                }
                                return str.trim();
                            };

                            const readRational = (
                                offset: number,
                                numValues: number,
                                littleEndian: boolean
                            ) => {
                                const values = [];
                                for (let i = 0; i < numValues; i++) {
                                    const num = view.getUint32(offset + i * 8, littleEndian);
                                    const den = view.getUint32(offset + i * 8 + 4, littleEndian);
                                    const val = den === 0 ? 0 : num / den;

                                    values.push(Math.round(val * 1000) / 1000);
                                }
                                return values;
                            };

                            parseIFD(tiffStart + ifdOffset);
                            break;
                        } else {
                            const l = view.getUint16(offset + 2, false);
                            offset += 2 + l;
                        }
                    }
                    resolve(tags);
                } catch (err) {
                    console.error("Exif parse error", err);
                    resolve({});
                }
            };
            reader.readAsArrayBuffer(file.slice(0, 128 * 1024));
        });
    }

    resetBtn?.addEventListener("click", () => {
        resultState?.classList.add("opacity-0");
        setTimeout(() => {
            resultState?.classList.add("hidden");
            initialState?.classList.remove("hidden");
            fileInput!.value = "";
        }, 300);
    });
</script>

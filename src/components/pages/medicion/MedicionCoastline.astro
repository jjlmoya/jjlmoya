---

---

<section
    class="min-h-screen flex flex-col items-center justify-center relative py-32 bg-[#09090b] text-cyan-50"
>
    <div class="container mx-auto px-6 max-w-4xl">
        <div class="flex flex-col md:flex-row gap-16 items-center">
            <div class="w-full md:w-1/2 space-y-8">
                <h2 class="text-4xl md:text-5xl font-serif italic text-cyan-200">
                    La Paradoja de la Costa
                </h2>

                <p class="text-lg leading-relaxed font-serif text-cyan-100/80">
                    ¿Cuánto mide la costa de Gran Bretaña? La respuesta depende de tu regla.
                </p>
                <p class="text-lg leading-relaxed font-serif text-cyan-100/80">
                    Si mides con una regla de 100km, obtienes un número. Si usas una de 1m, el
                    número crece. Si mides cada grano de arena, la longitud tiende al infinito.
                </p>

                <div class="space-y-4 mt-8">
                    <div class="bg-cyan-900/20 p-6 rounded-sm border-l-2 border-cyan-500/50">
                        <p class="text-sm text-cyan-100/90 leading-relaxed">
                            <strong>Fractales:</strong> La geometría de la naturaleza es rugosa. La precisión
                            absoluta en la medición de formas naturales es una ilusión.
                        </p>
                    </div>
                </div>
            </div>

            <div class="w-full md:w-1/2 flex flex-col items-center justify-center">
                <div
                    class="relative w-full aspect-square max-w-md bg-neutral-900/50 rounded-xl border border-cyan-900/30 overflow-hidden shadow-2xl shadow-cyan-900/10"
                >
                    <canvas id="coastline-canvas" class="w-full h-full opacity-80"></canvas>

                    <div class="absolute bottom-4 left-4 right-4 flex justify-between items-end">
                        <div
                            class="bg-black/80 backdrop-blur-md p-3 rounded border border-cyan-500/20 shadow-lg"
                        >
                            <div class="text-[10px] text-cyan-400 uppercase tracking-widest mb-1">
                                Tamaño de Regla
                            </div>
                            <div id="ruler-size" class="text-lg font-mono font-bold text-white">
                                --
                            </div>
                        </div>
                        <div
                            class="bg-black/80 backdrop-blur-md p-3 rounded border border-cyan-500/20 text-right shadow-lg"
                        >
                            <div class="text-[10px] text-cyan-400 uppercase tracking-widest mb-1">
                                Longitud Total
                            </div>
                            <div
                                id="measured-length"
                                class="text-lg font-mono font-bold text-cyan-200"
                            >
                                --
                            </div>
                        </div>
                    </div>
                </div>
                <p class="text-xs text-cyan-500/40 mt-4 font-mono text-center">
                    Simulación: Midiendo una isla fractal con distinta precisión
                </p>
            </div>
        </div>
    </div>
</section>

<script>
    const canvas = document.getElementById("coastline-canvas") as HTMLCanvasElement;
    const rulerEl = document.getElementById("ruler-size");
    const lengthEl = document.getElementById("measured-length");

    if (canvas && rulerEl && lengthEl) {
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("Canvas context not found");

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;

        
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);

        const center = { x: width / 2, y: height / 2 };
        const radius = Math.min(width, height) * 0.35;
        const totalPoints = 360; 

        interface Point {
            x: number;
            y: number;
        }
        const points: Point[] = [];

        
        for (let i = 0; i < totalPoints; i++) {
            const angle = (i / totalPoints) * Math.PI * 2;
            let r = radius;
            
            r += Math.sin(angle * 3) * 20;
            r += Math.cos(angle * 7) * 15;
            r += Math.sin(angle * 13) * 8;
            r += Math.cos(angle * 29) * 4;
            r += Math.sin(angle * 53) * 2;

            points.push({
                x: center.x + Math.cos(angle) * r,
                y: center.y + Math.sin(angle) * r,
            });
        }
        points.push(points[0]); 

        
        const resolutions = [
            { step: 40, label: "Muy Grande" }, 
            { step: 20, label: "Grande" },
            { step: 10, label: "Media" },
            { step: 5, label: "Fina" },
            { step: 1, label: "Atómica" }, 
        ];
        let currentResIndex = 0;

        function draw() {
            if (!ctx) return;
            
            ctx.clearRect(0, 0, width, height);

            
            ctx.beginPath();
            ctx.strokeStyle = "rgba(34, 211, 238, 0.1)"; 
            ctx.lineWidth = 1;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();

            
            const res = resolutions[currentResIndex];
            const step = res.step;
            let measuredLen = 0;

            ctx.beginPath();
            ctx.strokeStyle = "#22d3ee"; 
            ctx.lineWidth = 2;

            let currentIdx = 0;
            const measurePoints: Point[] = [];
            measurePoints.push(points[0]);

            ctx.moveTo(points[0].x, points[0].y);

            while (currentIdx < points.length - 1) {
                let nextIdx = currentIdx + step;
                if (nextIdx >= points.length - 1) nextIdx = points.length - 1;

                const p1 = points[currentIdx];
                const p2 = points[nextIdx];

                ctx.lineTo(p2.x, p2.y);

                const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                measuredLen += dist;

                measurePoints.push(p2);
                currentIdx = nextIdx;
                if (currentIdx >= points.length - 1) break;
            }
            ctx.stroke();

            
            ctx.fillStyle = "#fff";
            measurePoints.forEach((p) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            
            if (rulerEl) rulerEl.innerText = res.label;
            
            const displayLen = Math.floor(measuredLen * 1.5);
            if (lengthEl) lengthEl.innerText = displayLen.toLocaleString() + " km";

            
            currentResIndex = (currentResIndex + 1) % resolutions.length;
        }

        
        draw();
        
        setInterval(draw, 1500);
    }
</script>

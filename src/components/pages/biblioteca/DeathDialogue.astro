---
interface Props {
    text: string;
    onComplete?: () => void;
    speed?: number;
    delay?: number;
    autoStart?: boolean;
    mode?: "char" | "word";
}

const { text, speed = 50, delay = 0, autoStart = true, mode = "char" } = Astro.props;
---

<div
    class="death-dialogue-container font-serif text-xl md:text-2xl leading-relaxed tracking-wide text-[#e7e5e4] max-w-2xl mx-auto text-center min-h-[100px] flex items-center justify-center"
    data-auto-start={autoStart.toString()}
    data-speed={speed}
    data-delay={delay}
>
    <p class="death-text transition-opacity duration-500">
        {
            text.split(/<br\s*\/?>/i).map((part, index, array) => (
                <>
                    {mode === "char"
                        ? part
                              .toUpperCase()
                              .split("")
                              .map((char) => (
                                  <span class="death-anim-unit opacity-0 transition-opacity duration-75">
                                      {char === " " ? "\u00A0" : char}
                                  </span>
                              ))
                        : part
                              .toUpperCase()
                              .split(" ")
                              .map((word, wIndex, wArray) => (
                                  <span class="death-anim-unit opacity-0 transition-all duration-700 ease-out">
                                      {word}
                                      {wIndex < wArray.length - 1 ? " " : ""}
                                  </span>
                              ))}
                    {index < array.length - 1 && <br />}
                </>
            ))
        }
    </p>
</div>

<script is:inline>
    document.addEventListener("DOMContentLoaded", () => {
        const containers = document.querySelectorAll(".death-dialogue-container");

        containers.forEach((container) => {
            // Check if already initialized to prevent double-binding in some edge cases
            if (container.hasAttribute("data-initialized")) return;
            container.setAttribute("data-initialized", "true");

            const units = container.querySelectorAll(".death-anim-unit");
            const speed = parseInt(container.getAttribute("data-speed") || "50");
            const delay = parseInt(container.getAttribute("data-delay") || "0");
            const autoStart = container.getAttribute("data-auto-start") === "true";

            const startTyping = () => {
                // Reset opacity
                units.forEach((c) => c.classList.add("opacity-0"));

                setTimeout(() => {
                    let i = 0;
                    const revealUnit = () => {
                        if (i < units.length) {
                            units[i].classList.remove("opacity-0");
                            i++;
                            setTimeout(revealUnit, speed);
                        } else {
                            const event = new CustomEvent("dialogue-complete");
                            container.dispatchEvent(event);
                        }
                    };
                    revealUnit();
                }, delay);
            };

            if (autoStart) {
                startTyping();
            }

            // Listen for manual trigger
            // We use a named handler if we wanted to remove it, but since these are fresh elements, it's fine.
            container.addEventListener("start-typing", () => {
                startTyping();
            });
        });
    });
</script>

<style>
    .death-text {
        font-family: "Cinzel", serif;
        font-variant: small-caps;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    /* Ghostly reveal effect */
    .death-anim-unit.opacity-0 {
        filter: blur(8px);
        transform: scale(0.95);
    }

    .death-anim-unit {
        filter: blur(0);
        transform: scale(1);
    }
</style>

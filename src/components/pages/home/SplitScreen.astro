---
import GameBobLogo from "../../GameBobLogo.astro";

const linksLeft = [
    { label: "proyectos", href: "/proyectos/" },
    { label: "utilidades", href: "/utilidades/" },
    { label: "conceptos", href: "/conceptos/" },
];

const linksRight = [
    { label: "jugar", href: "/gamebob/" },
    { label: "roadmap", href: "/gamebob/roadmap/" },
    { label: "mec√°nicas", href: "/gamebob/mecanicas/" },
];
---

<div class="relative w-full h-screen flex flex-col md:block overflow-hidden font-sans">
    <!-- JJLMOYA SECTION (Left / Top) -->
    <section
        class="relative w-full h-[50vh] md:h-full md:absolute md:inset-0 bg-[#f0f0f0] text-slate-900 flex items-center justify-center md:justify-start md:pl-32 z-0"
    >
        <div class="relative z-10 flex flex-col items-center md:items-start">
            <h2
                class="text-6xl md:text-[9rem] font-black tracking-tighter mb-6 md:mb-10 leading-[0.8]"
            >
                jjlmoya
            </h2>
            <nav class="flex flex-col gap-4 items-center md:items-start">
                {
                    linksLeft.map((link) => (
                        <a
                            href={link.href}
                            class="text-2xl md:text-3xl font-light tracking-wide border-b-2 border-slate-900"
                        >
                            {link.label}
                        </a>
                    ))
                }
            </nav>
        </div>

        <!-- Background Texture -->
        <div
            class="absolute inset-0 opacity-[0.05] bg-[url('https://www.transparenttextures.com/patterns/concrete-wall.png')] pointer-events-none mix-blend-multiply"
        >
        </div>
    </section>

    <!-- Bubbles Container (The "Invasion" Effect) -->
    <div id="bubbles-container" class="absolute inset-0 z-20 pointer-events-none overflow-hidden">
        <!-- Bubbles will be injected here by script -->
    </div>

    <!-- GAMEBOB SECTION (Right / Bottom) -->
    <section
        class="gamebob-section relative w-full h-[50vh] md:h-full md:absolute md:inset-0 bg-[#050505] text-white flex items-center justify-center md:justify-end md:pr-32 z-10"
    >
        <!-- Updated Layout: Centered items, smaller logo -->
        <div class="relative z-10 flex flex-col items-center md:items-center text-right">
            <div class="w-20 md:w-32 mb-4">
                <GameBobLogo />
            </div>
            <h2 class="text-5xl md:text-[8rem] font-black mb-6 md:mb-10 leading-[0.8]">
                <span class="text-white">Game</span><span
                    class="text-transparent bg-clip-text bg-gradient-to-br from-[#1ddabc] to-[#128c7e]"
                    >Bob</span
                >
            </h2>
            <nav class="flex flex-col gap-4 items-center md:items-end">
                {
                    linksRight.map((link) => (
                        <a
                            href={link.href}
                            class="text-2xl md:text-3xl font-bold lowercase text-[#1ddabc] border-b-2 border-[#1ddabc]"
                        >
                            {link.label}
                        </a>
                    ))
                }
            </nav>
        </div>

        <!-- Grid & Effects -->
        <div
            class="absolute inset-0 opacity-20 pointer-events-none bg-[linear-gradient(45deg,#1ddabc1a_1px,transparent_1px)] bg-[size:30px_30px]"
        >
        </div>
        <div
            class="absolute inset-0 opacity-[0.07] pointer-events-none bg-[url('https://www.transparenttextures.com/patterns/stardust.png')]"
        >
        </div>
    </section>
</div>

<style>
    @media (min-width: 768px) {
        .gamebob-section {
            /* Liquid wave split */
            /* 4 points along the left edge to create a curve */
            clip-path: polygon(55% 0, 51.5% 33%, 48.5% 66%, 45% 100%, 100% 100%, 100% 0);
            animation: liquid-wave 30s ease-in-out infinite;
            will-change: clip-path;
        }
    }

    @keyframes liquid-wave {
        0%,
        100% {
            clip-path: polygon(55% 0, 51.5% 33%, 48.5% 66%, 45% 100%, 100% 100%, 100% 0);
        }
        25% {
            clip-path: polygon(54.5% 0, 52.5% 33%, 49% 66%, 45.5% 100%, 100% 100%, 100% 0);
        }
        50% {
            clip-path: polygon(55% 0, 52% 33%, 48% 66%, 45% 100%, 100% 100%, 100% 0);
        }
        75% {
            clip-path: polygon(55.5% 0, 51% 33%, 48% 66%, 44.5% 100%, 100% 100%, 100% 0);
        }
    }

    /* Bubble Base Styles */
    :global(.invasion-bubble) {
        position: absolute;
        border-radius: 50%;
        /* Solid flat bubbles */
    }

    /* White Bubbles */
    :global(.bubble-white) {
        background-color: #f0f0f0;
        /* Mobile: Downwards */
        animation: invade-down 3s ease-out infinite;
    }

    /* Black Bubbles */
    :global(.bubble-black) {
        background-color: #050505;
        /* Mobile: Upwards */
        animation: invade-up 3s ease-out infinite;
    }

    /* Desktop Overrides */
    @media (min-width: 768px) {
        :global(.bubble-white) {
            animation: invade-right 3s ease-out infinite;
        }
        :global(.bubble-black) {
            animation: invade-left 3s ease-out infinite;
        }
    }

    /* Desktop Animations */
    @keyframes invade-right {
        0% {
            transform: translate(0, 0) scale(0);
            opacity: 1;
        }
        50% {
            transform: translate(2vw, 0) scale(1);
            opacity: 1;
        }
        85% {
            transform: translate(4vw, 0) scale(1.5);
            opacity: 1;
        }
        100% {
            transform: translate(5vw, 0) scale(2);
            opacity: 0;
        }
    }

    @keyframes invade-left {
        0% {
            transform: translate(0, 0) scale(0);
            opacity: 1;
        }
        50% {
            transform: translate(-2vw, 0) scale(1);
            opacity: 1;
        }
        85% {
            transform: translate(-4vw, 0) scale(1.5);
            opacity: 1;
        }
        100% {
            transform: translate(-5vw, 0) scale(2);
            opacity: 0;
        }
    }

    /* Mobile Animations */
    @keyframes invade-down {
        0% {
            transform: translate(0, 0) scale(0);
            opacity: 1;
        }
        50% {
            transform: translate(0, 2vh) scale(1);
            opacity: 1;
        }
        85% {
            transform: translate(0, 4vh) scale(1.5);
            opacity: 1;
        }
        100% {
            transform: translate(0, 5vh) scale(2);
            opacity: 0;
        }
    }

    @keyframes invade-up {
        0% {
            transform: translate(0, 0) scale(0);
            opacity: 1;
        }
        50% {
            transform: translate(0, -2vh) scale(1);
            opacity: 1;
        }
        85% {
            transform: translate(0, -4vh) scale(1.5);
            opacity: 1;
        }
        100% {
            transform: translate(0, -5vh) scale(2);
            opacity: 0;
        }
    }
</style>

<script>
    function randomizeBubble(bubble: HTMLElement, forcedType?: "white" | "black") {
        const isMobile = window.innerWidth < 768;

        // Determine type:
        // 1. If forcedType is provided, use it.
        // 2. Else if bubble already has a class, keep it (unless we want to re-roll, but keeping is safer for stability).
        // 3. Else random.
        let isWhite;
        if (forcedType) {
            isWhite = forcedType === "white";
        } else if (bubble.classList.contains("bubble-white")) {
            isWhite = true;
        } else if (bubble.classList.contains("bubble-black")) {
            isWhite = false;
        } else {
            isWhite = Math.random() > 0.5;
        }

        // Ensure class is set
        bubble.classList.remove("bubble-white", "bubble-black");
        bubble.classList.add(isWhite ? "bubble-white" : "bubble-black");

        let x, y, size;

        if (isMobile) {
            // Mobile: Horizontal split at 50% height
            // White (Top) invades Down
            // Black (Bottom) invades Up

            // Random X along the width
            x = Math.random() * 100;

            const borderY = 50;
            // White starts slightly above (negative offset), Black slightly below (positive offset)
            const startOffset = isWhite ? -1 : 1;
            const scatter = (Math.random() - 0.5) * 2;

            y = borderY + startOffset + scatter;
        } else {
            // Desktop: Vertical/Diagonal split
            // White (Left) invades Right
            // Black (Right) invades Left

            // y goes from 0 to 100%
            y = Math.random() * 100;
            // x is interpolated based on y (approximate diagonal)
            const borderX = 55 - (y / 100) * 10;

            // White starts slightly left, Black slightly right
            const startOffset = isWhite ? -1.5 : 1.5;
            const scatter = (Math.random() - 0.5) * 1;

            x = borderX + startOffset + scatter;
        }

        size = 10 + Math.random() * 40; // 10px to 50px
        const duration = 8 + Math.random() * 8; // 8s to 16s

        bubble.style.left = `${x}%`;
        bubble.style.top = `${y}%`;
        bubble.style.width = `${size}px`;
        bubble.style.height = `${size}px`;
        bubble.style.animationDuration = `${duration}s`;
    }

    function createInvasion() {
        const container = document.getElementById("bubbles-container");
        if (!container) return;

        container.innerHTML = "";

        const numBubbles = 2; // Anecdotal density

        for (let i = 0; i < numBubbles; i++) {
            const bubble = document.createElement("div");
            bubble.classList.add("invasion-bubble");

            // Force one white and one black for balance if count is 2
            let forcedType: "white" | "black" | undefined;
            if (numBubbles === 2) {
                forcedType = i === 0 ? "white" : "black";
            }

            // Initial Randomization
            randomizeBubble(bubble, forcedType);

            // Much longer delay range for anecdotal appearance
            const initialDelay = Math.random() * -25;
            bubble.style.animationDelay = `${initialDelay}s`;

            // Re-randomize on every loop
            // Note: We don't pass forcedType here so it stays what it was (logic inside randomizeBubble keeps existing class)
            // OR we can let it be random. The user wants "some white bubbles too".
            // If we keep the class, it stays white forever. If we re-roll, it might change.
            // Let's keep the class to ensure the balance persists.
            bubble.addEventListener("animationiteration", () => {
                randomizeBubble(bubble);
            });

            container.appendChild(bubble);
        }
    }

    createInvasion();
    window.addEventListener("resize", () => {
        // Debounce or just re-run? Re-running is fine for this scale.
        createInvasion();
    });
</script>
